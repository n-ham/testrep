Lattice path enumeration algorithms
=====

The code in this project contains implementations of algorithms 1-3 from the paper [Lattice paths and submonoids of $`\mathbb{Z}^2`$]() `(NEED TO ADD LINK)` by James East and Nicholas Ham. 

### Installation
In your terminal of choice, perform the following steps to install this project:

1. Clone this repository by entering 

        git clone https://gitlab.com/n-ham-paper-files/lattice-path-algorithms
      
    This will create a directory called `lattice-path-algorithms` in whatever directory you were in to begin with.
2. Type `cd lattice-path-algorithms` to change directory into the `lattice-path-algorithms` directory created in Step 1.
3. Type `make` which will create executables for the three programs in this project `egalgo1`, `egalgo2` and `egalgo3`. This project is written in C++11, so you will require a C++ compiler compatible with this standard.

You might want to test that everything worked by entering `make test` which should, provided you have not uncommented any output statements in `egalgo[1-3].cc`, display:

	./egalgo1
	./egalgo2
	./egalgo3
    
but nothing further.

-----

### Sample `input.txt` file
The `input.txt` file in the `lattice-path-algorithms` directory is formatted as:

	noSteps
	x y stepDirection bendAmount edgeColour

	noConstraints
	[<=,<,>=,>] a b

where: 
* `noSteps` is the number of steps below;
* `x` is the horizontal distance travelled by the input step;
* `y` is the vertical distance travelled by the input step;
* `stepDirection` is the direction to bend edges in the TikZ output for algorithms 1 and 3;
* `bendAmount` is the amount of bend on edges in the TikZ output for algorithms 1 and 3;
* `edgeColour` is the colour of the edges in TikZ output for algorithms 1 and 3;
* `noConstraints` is the number of constraints below;
* `[<=,<,>=,>]` indicates the type of constraint; and
* `a` and `b` are the slope and intercept of the linear line that points must be less/greater than (or equal to).

An example `input.txt` file is:

	3
	0 1 left 0 red
	1 0 left 0 blue
	2 2 left 30 green
	2
	<= 1 0
	>= 0 0

Which consists of the step set $`\left\{(0, 1), (1, 0), (1, 1)\right\}`$ along with the linear constraints $`\left\{(x, y) \in \mathbb{Z}^2: y \leq x\right\}`$ and $`\left\{(x, y) \in \mathbb{Z}^2: y \geq 0\right\}`$.

Note if you would like to put constraints on the value of $`x`$, for example $`\left\{(x, y) \in \mathbb{Z}^2: x \geq 0\right\}`$ or $`\left\{(x, y) \in \mathbb{Z}^2: x \leq 10\right\}`$, then try hard-coding the constraint in to the function `algorithm1` (located in `algorithms.h`) below the comment:

	//this is a good place to hard-code constraints on x, eg. x >= 0 or x <= 10

-----

### TikZ code saved to `output.txt`
All three algorithms have the option of saving relevant TikZ code to `output.txt`. The `lattice-path-algorithms` directory contains an example file `example.tex` which the TikZ code can be copied in to then compiled. If you would like to copy the TikZ code in to your own `.tex` files you will need to include the following in your preamble:

    \usepackage{tikz, mathrsfs}

    \usetikzlibrary{decorations.markings}

	\tikzset{->-/.style={decoration={
		markings,
		mark=at position #1 with {\arrow{>}}},postaction={decorate}}}
	\tikzset{-<-/.style={decoration={
		markings,
		mark=at position #1 with {\arrow{<}}},postaction={decorate}}}

<!-- this comment fixes syntax highlighting in gedit and other text editors -->

Once path counts exceed 100 it is possible to start getting 'Dimension too large' errors when compiling the TikZ code generated by algorithms 1 and 3. LaTeX throws an error when drawing edges between vertices that are too big and too close together. If you would like to prevent algorithms 1 and 3 adding TikZ code for edges between vertices that are too big and too close together, edit the output function for graphs `std::ostream& operator<<(std::ostream& os, Graph& graph)` where edges are added to the output stream. You may like to try uncommenting and modifying some of the code below the comment:

        /*
            if you get 'Dimension too large' error(s), try not outputting 
            edges between vertices with large labels, especially vertices
            close together.
        */

-----

### Computing the end point sets $`\mathscr{A}_X^{\mathscr{C}}(i)`$ and the graphs $`\Lambda_{X}^{\mathscr{C}}(i)`$ for $`i = 0, 1, \ldots, q`$
The function `algorithm1` located in `algorithms.h` takes inputs:
* a finite step set $`X \subseteq \mathbb{Z}^2_{\times}`$;
* constraints $`\mathscr{C}`$ of the form `[<=,<,>=,>] a b` where `a` is the slope and `b` is the intercept of the linear line that points must be less/greater than (or equal to);
* a positive integer $`q \in \mathbb{P}`$; and
* a bool variable `saveTikZ` indicating whether TikZ code for the graphs $`\Lambda_{X}^{\mathscr{C}}(i)`$ for $`i = 0, 1, \ldots, q`$ will be saved to `output.txt`,

then computes:
* the end point sets $`\mathscr{A}_X^{\mathscr{C}}(i)`$ for $`i = 0, 1, \ldots, q`$ which are stored in the input variable `endPointSets`.
* the graphs $`\Lambda_{X}^{\mathscr{C}}(i)`$ for $`i = 0, 1, \ldots, q`$ which are stored in the input variable `graphs`.

Running `egalgo1` will read $`X`$ and $`\mathscr{C}`$ from `input.txt` then run `algorithm1` with `saveTikZ` set to `true`, which saves TikZ code for the graphs $`\Lambda_{X}^{\mathscr{C}}(i)`$ for $`i = 0, 1, \ldots, q`$ to `output.txt`. Note that $`q`$ is declared at the beginning of `egalgo1.cc`, which can be overridden by including an input parameter when running `egalgo1` (for example by running `./egalgo1 12`).


-----

### Checking the line condition
The function `algorithm2` located in `algorithms.h` takes inputs:
* a finite step set $`X \subseteq \mathbb{Z}^2_{\times}`$; and
* a bool variable `saveTikZ` indicating whether TikZ code for the graph containing $`X, \mathscr{L}`$ and $`\textbf{u}`$ will be saved to `output.txt`,

then computes:
* whether $`X`$ satisfies FPP for BPP, which is stored in the input variable `property`.
* if $`X`$ satisfies FPP, a vector $`\textbf{u}`$ such that the line $`\mathscr{L}`$ through $`O`$ and perpendicular to $`\textbf{u}`$ witnesses the LC, with $`\textbf{u}`$ pointing towards the half-plane containing $`X`$, which is stored in the input variable `u`.

Running `egalgo2` will read $`X`$ from `input.txt` then run `algorithm2` with `saveTikZ` set to `true`, which saves TikZ code for the graph containing $`X, \mathscr{L}`$ and $`\textbf{u}`$ to `output.txt`.

-----

### Computing the graph $`\Gamma_{X}^{\mathscr{C}}[q]`$
The function `algorithm3` located in `algorithms.h` takes inputs:
* a finite step set $`X \subseteq \mathbb{Z}^2_{\times}`$;
* constraints $`\mathscr{C}`$ of the form `[<=,<,>=,>] a b` where `a` is the slope and `b` is the intercept of the linear line that points must be less/greater than (or equal to);
* a positive integer $`q \in \mathbb{P}`$; and
* a bool variable `saveTikZ` indicating whether TikZ code for the graph $`\Gamma_{X}^{\mathscr{C}}[q]`$ will be saved to `output.txt`,

then computes:
* the graph $`\Gamma_{X}^{\mathscr{C}}[q]`$ which is stored in the input variable `graph`.

Running `egalgo3` will read $`X`$ and $`\mathscr{C}`$ from `input.txt` then run `algorithm3` with `saveTikZ` set to `true`, which saves TikZ code for the graph $`\Gamma_{X}^{\mathscr{C}}[q]`$ to `output.txt`. Note that $`q`$ is declared at the beginning of `egalgo3.cc`, which can be overridden by including an input parameter when running `egalgo3` (for example by running `./egalgo3 12`).

-----

Enjoy!

Copyright (C) 2018 Nicholas C. Ham

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.

